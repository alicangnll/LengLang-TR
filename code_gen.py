"""
The code generation step of ShivC. Recursively parses the tree to generate
asm code.
"""

import rules
import tokens
from lexer import *

from code_gen_obj import *

#########################################################
#                                                       #
#   This function is disgustingly long. TODO: fix it!   #
#                                                       #
#########################################################

def make_code(root, info, code,
              has_else = False, endelse_label = "",  # adds an extra jump label if the "if" has an "else"
              loop_break = None, loop_continue = None):
    """Called recursively to generate asm code from the parse tree.

    Should generate asm code such that the top of the machine stack stores the 
    result of the node's computation when the function returns.
     
    May assume that at the end of a single call of make_code, the asm generated
    pushes at most one new element onto the stack: the value calculated by the
    current node. MAY NOT assume that the asm generated by make_code
    preserves any registers, with some noted exceptions.

    root - the root node being considered for code generation
    info - A StateInfo object storing the current state
    code - A CodeManager object storing the current code
    has_else - Used only when parsing an `if` to indicate there exists an `else`
    endelse_label - Again, used to indicate the label of this else for jump
    loop_break - The label to jump to if a loop is broken out of
    loop_continue - The label to jump to if a loop is continued"""

    # Counts the number of asterisks on a separator or type node
    def count_asterisks(node):
        if len(node.children) == 1: return 0
        else: return 1 + count_asterisks(node.children[0])

    # Processes a function argument list
    # returns:
    # [(function name, function return type), (function argument name, function argument type)]
    def process_dec(node):
        if node.rule == rules.base_arg_form:
            return [(node.children[0].children[1].text, Type("int", count_asterisks(node.children[0].children[0]))),
                    (node.children[2].children[1].text, Type("int", count_asterisks(node.children[2].children[0])))]
        elif node.rule == rules.cont_arg_form:
            return (process_dec(node.children[0])
                    + [(node.children[2].children[1].text, Type("int", count_asterisks(node.children[2].children[0])))])
    
    if (root.rule == rules.main_func_def_cont or
        root.rule == rules.main_func_dec_cont):
        # Make code for both children in order
        info = make_code(root.children[0], info, code,
                         loop_break=loop_break, loop_continue=loop_continue)
        info = make_code(root.children[1], info, code,
                         loop_break=loop_break, loop_continue=loop_continue)
        
    elif root.rule == rules.main_func_dec or root.rule == rules.main_func_def:
        # Make code for the only child
        info = make_code(root.children[0], info, code,
                         loop_break=loop_break, loop_continue=loop_continue)

    elif root.rule == rules.func_dec_form:
        # Add the function to the StateInfo object, and get a new label from the
        # CodeManager for the function address
        p = process_dec(root.children[0])
        info = info.add_func(p[0][0], p[0][1], p[1:], code.get_label())

    elif root.rule == rules.func_def_form:
        p = process_dec(root.children[0])

        # If the function is already declared, this definition better be same
        if info.func_declared(p[0][0]):
            prefunc = info.get_func(p[0][0])
            if (prefunc.fname != p[0][0] or
                prefunc.ftype != p[0][1] or
                prefunc.args != p[1:]): raise VariableRedeclarationException(p[0][0])
        else:
            # if not, declare it right now
            info = info.add_func(p[0][0], p[0][1], p[1:], code.get_label())

        f = info.get_func(p[0][0])
        code.add_label(f["label"])

        # we don't want to change the main `info` when adding function arguments
        info_t = info.c()
        for arg in f["args"]:
            # add the arguments to the representation of memory so we can
            # access them in make_code for the function body
            info_t = info_t.add(arg[0], arg[1]) 

        # make code for the function body
        make_code(root.children[3], info_t, code)

    elif root.rule == rules.noarg_func_dec_form:
        # Add the function declaration into our function table
        info = info.add_func(root.children[0].children[1].text, # function name
                             # function return type
                             Type("int", count_asterisks(root.children[0].children[0])),
                             [], # function argument list (empty)
                             code.get_label())
        
    elif root.rule == rules.noarg_func_def_form:
        # if already declared, it better be the same
        if info.func_declared(root.children[0].children[1].text):
            prefunc = info.get_func(root.children[0].children[1].text)
            if (prefunc.ftype.pointers != count_asterisks(node.children[0].children[0])
                or len(prefunc.args) != 0):
                raise VariableRedeclarationException(func_namroot.children[0].children[1].text)
        else:
            # declare it
            info = info.add_func(root.children[0].children[1].text,
                                 Type("int", count_asterisks(root.children[0].children[0])),
                                 [],
                                 code.get_label())

        # add the function
        f = info.get_func(root.children[0].children[1].text)
        code.add_label(f["label"])

        info_t = info.c()
        make_code(root.children[4], info_t, code)
        
    elif root.rule == rules.statements_cont:
        # make code for first statement
        info = make_code(root.children[0], info, code, loop_break=loop_break, loop_continue=loop_continue)
        # remove all temporary stack stuff by resetting rsp to the correct location
        code.add_command("lea", "rsp", "[rbp - " + str(info.var_offset * 8) + "]")
        # make code for next statement
        info = make_code(root.children[1], info, code, loop_break=loop_break, loop_continue=loop_continue)
        
    elif root.rule == rules.statements_end:
        # Make code for only child
        info = make_code(root.children[0], info, code, loop_break=loop_break, loop_continue=loop_continue)
        
    elif root.rule == rules.return_form:
        # Generate code to push the return value onto top of stack
        info = make_code(root.children[1], info, code)

        # [rbp+8] stores the execution position before the function was entered,
        # per the calling convention we're using
        code.add_command("mov", "rax", "[rbp + 8]")
        # move the return value into [rbp+8]
        code.add_command("pop", "rbx")
        code.add_command("mov", "[rbp + 8]", "rbx")
        # move the stack pointer to [rbp+8], which now stores the returned value
        code.add_command("lea", "rsp", "[rbp + 8]")
        # [rbp] stores the rbp before the function was entered, per calling
        # convention, so we restore that
        code.add_command("mov", "rbp", "[rbp]")
        # return to wherever the code was before function was called
        code.add_command("jmp", "rax")

    elif root.rule == rules.print_form:
        # Prints out a number. Most of the asm is just to convert the number to
        # decimal for printing.
        info = make_code(root.children[1], info, code)
        isneg  = code.get_label()
        nextchar = code.get_label()
        done = code.get_label()
        nodash = code.get_label()
        code.add_command("mov", "r10", "10")
        code.add_command("pop", "rax")
        code.add_command("mov", "r8", "1")
        code.add_command("mov", "rbx", "10")
        code.add_command("mov", "r9", "0")
        code.add_command("cmp", "rax", "0")
        code.add_command("jl", isneg)
        code.add_command("jmp", nextchar)
        code.add_label(isneg)
        code.add_command("mov", "r9", "1")
        code.add_command("neg", "rax")
        code.add_label(nextchar)
        code.add_command("shl", "rbx", "8")
        code.add_command("mov", "rdx", "0")
        code.add_command("cqo")
        code.add_command("idiv", "r10")
        code.add_command("add", "rbx", "rdx")
        code.add_command("add", "rbx", "48")
        code.add_command("inc", "r8")
        code.add_command("cmp", "rax", "0")
        code.add_command("je", done)
        code.add_command("jmp", nextchar)
        code.add_label(done)
        code.add_command("cmp", "r9", "0")
        code.add_command("je", nodash)
        code.add_command("shl", "rbx", "8")
        code.add_command("add", "rbx", "45")
        code.add_command("inc", "r8")
        code.add_label(nodash)
        code.add_command("mov", "rdx", "r8")
        code.add_command("push", "rbx")
        code.add_command("mov", "rax", "0x2000004")
        code.add_command("mov", "rdi", "1")
        code.add_command("mov", "rsi", "rsp")
        code.add_command("syscall")
        
    elif root.rule == rules.useless_declaration: pass
    
    elif root.rule == rules.real_declaration:
        # This one is unique because we have to parse the whole tree to get what we need
        node = root
        while node.rule != rules.declare_type_base: # get the type of this declaration
            node = node.children[0]
        dec_type = node.children[0].text
        if dec_type != "int": raise RuleGenException(root.rule) # only int is supported right now
        else:
            node = root
            next_val = None
            next_array = False
            next_size = 0
            
            declarations = []

            # Construct an ordered list of the declarations needed
            while True:
                if node.rule == rules.real_declaration:
                    node = node.children[0]
                elif node.rule == rules.assign_declare or node.rule == rules.arr_assign_declare:
                    next_val = node.children[2]
                    node = node.children[0]
                elif node.rule == rules.cont_declare:
                    declarations.append((node.children[2].text, next_val, count_asterisks(node.children[1]),
                                         next_array, next_size))
                    next_val = None
                    next_array = False
                    next_size = 0
                    node = node.children[0]
                elif node.rule == rules.array_num_declare:
                    if ((node.children[0].rule != rules.base_declare and node.children[0].rule != rules.cont_declare) or
                        node.children[2].rule != rules.E_num):
                        raise RuleGenException(node.rule)
                    next_array = True
                    next_size = int(node.children[2].children[0].text)
                    if next_size < 0: raise RuleGenException(node.rule)
                    node = node.children[0]
                elif node.rule == rules.array_nonum_declare:
                    if node.children[0].rule != rules.base_declare and node.children[0].rule != rules.cont_declare:
                        raise RuleGenException(node.rule)
                    next_array = True
                    next_size = None
                    node = node.children[0]
                elif node.rule == rules.base_declare:
                    declarations.append((node.children[1].text, next_val, count_asterisks(node.children[0]),
                                         next_array, next_size))
                    break

            declarations.reverse()

            def get_array(node): # coverts something like {1, 2, 3} to list, in reverse order
                if node.rule == rules.arr_list_none: return []
                elif node.rule == rules.arr_list_one: return [node.children[1]]
                elif node.rule == rules.arr_list_total:
                    return [node.children[1].children[0]] + get_array(node.children[0])
                elif node.rule == rules.arr_list_cont:
                    return [node.children[1]] + get_array(node.children[0])
                elif node.rule == rules.arr_list_start:
                    return [node.children[1]]
                else: raise RuleGenException(node.rule)

            # Actually add each declaration into the StateInfo and generated asm
            # The array is stored with arr[0] nearest to the top of the stack.
            for (name, node, pointers, is_array, array_len) in declarations:
                if not is_array:
                    if node:
                        # push the assigned value onto the stack
                        info = make_code(node, info, code)
                    else:
                        # if no assignment, just push a 0 as value
                        code.add_command("push", "0")
                    # this new variable will automatically be created where the
                    # last value was pushed, as desired.
                    info = info.add(name, Type("int", pointers))
                else:
                    # if there is no size provided, but no initializer list
                    if array_len is None and node is None:
                        raise RuleGenException(root.rule)
                    
                    num_total = array_len
                    array_conts = get_array(node) if node else []

                    if num_total is not None:
                        # complain if provided list is bigger than array size
                        if len(array_conts) > num_total:
                            raise RuleGenException(root.rule)

                        # add 0s for array values that are not specified by initializer
                        # Example: int[5] arr = {1} requires adding 4 zeros
                        for i in range(num_total - len(array_conts)):
                            code.add_command("push", "0")
                            info = info.add_space()

                    # Add the initializer list contents to memory
                    for e in array_conts:
                        # push the node contents onto the stack
                        info = make_code(e, info, code)
                        info = info.add_space()

                    # push the array address onto the stack
                    code.add_command("lea", "rax", "[rbp - " + str(info.var_offset * 8) +  "]")
                    code.add_command("push", "rax")
                    # save the array as a variable of pointer type
                    info = info.add(name, Type("int", pointers + 1))
                
                # reset the stack pointer to the correct location
                code.add_command("lea", "rsp", "[rbp - " + str(info.var_offset * 8) +  "]")

    elif root.rule == rules.E_num:
        code.add_command("push", root.children[0].text)
        info.t = Type()
        
    elif root.rule == rules.E_parens:
        info = make_code(root.children[1], info, code)
        
    elif root.rule == rules.E_add:
        # Generate code to compute both operands
        info = make_code(root.children[0], info, code)
        type1 = info.t
        info = make_code(root.children[2], info, code)
        type2 = info.t
        # Save the operands into registers
        code.add_command("pop", "rbx")
        code.add_command("pop", "rax")

        if root.children[1].text == "+":
            # if one of them is a pointer, multiply by int size (8 bytes)
            if type1.pointers == 0 and type2.pointers > 0:
                code.add_command("imul", "rax", "8")
            elif type2.pointers == 0 and type1.pointers > 0:
                code.add_command("imul", "rbx", "8")
            elif type1.pointers == 0 and type2.pointers == 0:
                pass
            else: raise RuleGenException(root.rule)
            code.add_command("add", "rax", "rbx")
            
        elif root.children[1].text == "-":
            if type1.pointers == 0 and type2.pointers == 0:
                code.add_command("sub", "rax", "rbx")
            # if the first is pointer, multiply the second by int size
            elif type1.pointers > 0 and type2.pointers == 0:
                code.add_command("imul", "rbx", "8")
                code.add_command("sub", "rax", "rbx")
            # if both are pointers, find difference and DIVIDE by int size
            elif type1.pointers > 0 and type2.pointers > 0 and type1.pointers == type2.pointers:
                code.add_command("sub", "rax", "rbx")
                code.add_command("cqo")
                code.add_command("mov", "r8", "8")
                code.add_command("idiv", "r8")
            else: raise RuleGenException(root.rule)
        else: raise RuleGenException(root.rule)
        
        code.add_command("push","rax")
        info.t = Type("int", max(type1.pointers, type2.pointers))
        
    elif root.rule == rules.E_mult:
        info = make_code(root.children[0], info, code)
        type1 = info.t
        info = make_code(root.children[2], info, code)
        type2 = info.t
        if type1.pointers > 0 or type2.pointers > 0: raise RuleGenException(root.rule)
        
        code.add_command("pop", "rbx")
        code.add_command("pop", "rax")
        code.add_command("imul", "rax", "rbx")
        code.add_command("push", "rax")
        
    elif root.rule == rules.E_div:
        info = make_code(root.children[0], info, code)
        type1 = info.t
        info = make_code(root.children[2], info, code)
        type2 = info.t
        if type1.pointers > 0 or type2.pointers > 0: raise RuleGenException(root.rule)

        code.add_command("pop", "rbx")
        code.add_command("pop", "rax")
        code.add_command("cqo")
        code.add_command("idiv", "rbx")
        code.add_command("push", "rax")
        
    elif root.rule == rules.E_mod:
        info = make_code(root.children[0], info, code)
        type1 = info.t
        info = make_code(root.children[2], info, code)
        type2 = info.t
        if type1.pointers > 0 or type2.pointers > 0: raise RuleGenException(root.rule)

        code.add_command("pop", "rbx")
        code.add_command("pop", "rax")
        code.add_command("mov", "rdx", "0")
        code.add_command("cqo")
        code.add_command("idiv", "rbx")
        code.add_command("push", "rdx")

    elif root.rule == rules.E_boolean_and:
        # Make sure to short-circuit evaluate
        info = make_code(root.children[0], info, code)
        code.add_command("pop", "rax")
        push_0 = code.get_label()
        end = code.get_label()
        code.add_command("cmp", "rax", "0")
        code.add_command("je", push_0)
        info = make_code(root.children[2], info, code)
        code.add_command("pop", "rax")
        code.add_command("cmp", "rax", "0")
        code.add_command("je", push_0)
        code.add_command("push", "1")
        code.add_command("jmp", end)
        code.add_label(push_0)
        code.add_command("push", "0")
        code.add_label(end)

        info.t = Type("int")

    elif root.rule == rules.E_boolean_or:
        # Make sure to short-circuit evaluate
        info = make_code(root.children[0], info, code)
        code.add_command("pop", "rax")
        push_1 = code.get_label()
        end = code.get_label()
        code.add_command("cmp", "rax", "0")
        code.add_command("jne", push_1)
        info = make_code(root.children[2], info, code)
        code.add_command("pop", "rax")
        code.add_command("cmp", "rax", "0")
        code.add_command("jne", push_1)
        code.add_command("push", "0")
        code.add_command("jmp", end)
        code.add_label(push_1)
        code.add_command("push", "1")
        code.add_label(end)

        info.t = Type("int")
        
    elif root.rule == rules.E_eq_compare:
        info = make_code(root.children[0], info, code)
        info = make_code(root.children[2], info, code)
        code.add_command("pop", "rbx")
        code.add_command("pop", "rax")
        code.add_command("mov", "rcx", "0")
        code.add_command("cmp", "rax", "rbx")
        if root.children[1].text == "==": code.add_command("sete", "cl")
        elif root.children[1].text == "!=": code.add_command("setne", "cl")
        else: raise RuleGenException(root.rule)
        code.add_command("push", "rcx")

        info.t = Type("int")

    elif root.rule == rules.E_compare:
        info = make_code(root.children[0], info, code)
        info = make_code(root.children[2], info, code)
        code.add_command("pop", "rbx")
        code.add_command("pop", "rax")
        code.add_command("mov", "rcx", "0")
        code.add_command("cmp", "rax", "rbx")
        if root.children[1].text == "<": code.add_command("setl", "cl")
        elif root.children[1].text == "<=": code.add_command("setle","cl")
        elif root.children[1].text == ">": code.add_command("setg", "cl")
        elif root.children[1].text == ">=": code.add_command("setge", "cl")
        else: raise RuleGenException(root.rule)
        code.add_command("push", "rcx")

        info.t = Type("int")
        
    elif root.rule == rules.E_neg:
        info = make_code(root.children[1], info, code)
        if info.t.pointers > 0: raise RuleGenException(root.rule)
        if root.children[0].text == "-":
            code.add_command("pop", "rax")
            code.add_command("neg", "rax")
            code.add_command("push", "rax")
            
    elif root.rule == rules.E_equal and root.children[1] == tokens.equal:
        # Simple assignment
        left_base = root.children[0]

        # this is required so statements like `((a)) = 10;` work
        while left_base.rule == rules.E_parens:
            left_base = left_base.children[1]
        
        if left_base.rule == rules.E_var:
            # if the left is just a regular variable, then it's easy

            # Get the address of the variable we're storing into
            var_loc = info.get(left_base.children[0].text)
            # calculate the right hand side value
            info = make_code(root.children[2], info, code)
            # store the rhs value into the variable
            code.add_command("pop", "rax")
            code.add_command("mov", "[rbp - " + str(8*var_loc[0]) + "]", "rax")
            code.add_command("push", "rax")
            info.t = var_loc[1] # set the return type correctly
        elif left_base.rule == rules.E_point:
            # Cases like `*c = 10`

            # Get the address to save into
            info = make_code(left_base.children[1], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule)
            else: return_type = Type(info.t.type_name, info.t.pointers - 1)
            info = make_code(root.children[2], info, code)
            # save into that address
            code.add_command("pop", "rbx")
            code.add_command("pop", "rax")
            code.add_command("mov", "[rax]", "rbx")
            code.add_command("push", "rbx")
            info.t = return_type
        elif left_base.rule == rules.E_array:
            # if the left is like `a[5]`
            # compute the array index
            info = make_code(left_base.children[2], info, code)
            # compute the array name itself
            info = make_code(left_base.children[0], info, code)
            # compute the rhs values
            info = make_code(root.children[2], info, code)
            info.t = Type(info.t.type_name, info.t.pointers - 1)
            # save the value into the correct space in memory
            code.add_command("pop", "rcx")
            code.add_command("pop", "rax")
            code.add_command("pop", "rbx")
            code.add_command("imul", "rbx", "8") # hardcoded 8-bytes for int
            code.add_command("add", "rax", "rbx")
            code.add_command("mov", "[rax]", "rcx")
            code.add_command("push", "rcx")

        else: raise RuleGenException(root.rule)
            
    elif root.rule == rules.E_equal: # stuff like *= and /=

        # Again, deal with stuff like `((a)) = 10;`
        left_base = root.children[0]
        while left_base.rule == rules.E_parens: left_base = left_base.children[1]

        # In each case, we:
        # 1) Save the left and right values into rax and rbx respectively
        # 2) Set ltype and rtype to the types of the operands
        # 3) Set save_loc to the address to save the result to

        if left_base.rule == rules.E_var:
            var_loc = info.get(left_base.children[0].text)
            info = make_code(root.children[2], info, code)
            code.add_command("pop", "rbx")
            code.add_command("mov", "rax", "[rbp - " + str(8*var_loc[0]) + "]")
            ltype = var_loc[1]
            rtype = info.t
            save_loc = "[rbp - " + str(8*var_loc[0]) + "]"
        elif left_base.rule == rules.E_point:
            info = make_code(left_base.children[1], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule)
            else: ltype = Type(info.t.type_name, info.t.pointers - 1)
            info = make_code(root.children[2], info, code)
            rtype = info.t
            code.add_command("pop", "rbx")
            code.add_command("pop", "rcx")
            code.add_command("mov", "rax", "[rcx]")
            save_loc = "[rcx]"
        elif left_base.rule == rules.E_array:
            info = make_code(left_base.children[2], info, code)
            info = make_code(left_base.children[0], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule) 
            else: ltype = Type(info.t.type_name, info.t.pointers - 1)
            info = make_code(root.children[2], info, code)
            rtype = info.t
            code.add_command("pop", "rbx") # right hand side
            code.add_command("pop", "rcx") # rcx[r8]
            code.add_command("pop", "r8")
            code.add_command("imul", "r8", "8")
            code.add_command("add", "rcx", "r8")
            code.add_command("mov", "rax", "[rcx]")
            save_loc = "[rcx]"
        else: raise RuleGenException(root.rule)

        # Now, do the actual operation to change the value of rax
        if root.children[1] == tokens.plusequal:
            if ltype.pointers > 0 and rtype.pointers > 0: raise RuleGenException(root.rule)
            elif ltype.pointers > 0 and rtype.pointers == 0:
                code.add_command("imul", "rbx", "8")
            elif ltype.pointers == 0 and rtype.pointers > 0:
                code.add_command("imul", "rax", "8")
            code.add_command("add", "rax", "rbx")
        elif root.children[1] == tokens.minusequal:
            if ltype.pointers == 0 and rtype.pointers == 0:
                code.add_command("sub", "rax", "rbx")
            elif ltype.pointers > 0 and rtype.pointers == 0:
                code.add_command("imul", "rbx", "8")
                code.add_command("sub", "rax", "rbx")
            elif ltype.pointers > 0 and rtype.pointers > 0 and ltype.pointers == rtype.pointers:
                code.add_command("sub", "rax", "rbx")
                code.add_command("cqo")
                code.add_command("mov", "r8", "8")
                code.add_command("idiv", "r8")
            else:
                raise RuleGenException(root.rule)
        elif root.children[1] == tokens.timesequal:
            if ltype.pointers > 0 or rtype.pointers > 0: raise RuleGenException(root.rule)
            code.add_command("imul", "rax", "rbx")
        elif root.children[1] == tokens.divequal:
            if ltype.pointers > 0 or rtype.pointers > 0: raise RuleGenException(root.rule)
            code.add_command("cqo")
            code.add_command("idiv", "rbx")
        elif root.children[1] == tokens.modequal:
            if ltype.pointers > 0 or rtype.pointers > 0: raise RuleGenException(root.rule)
            code.add_command("mov", "rdx", "0")
            code.add_command("idiv", "rbx")
            code.add_command("mov", "rax", "rdx")
        else: raise RuleGenException(root.rule)

        # Move the value of rax to the save location, save_loc,
        # and push rax as the return value

        code.add_command("mov", save_loc, "rax")
        code.add_command("push", "rax")

        info.t = ltype

    elif root.rule == rules.E_boolean_not:
        info = make_code(root.children[1], info, code)
        code.add_command("pop", "rax")
        code.add_command("cmp", "rax", "0")
        label_1 = code.get_label()
        label_2 = code.get_label()
        code.add_command("je", label_1)
        code.add_command("push", "0")
        code.add_command("jmp", label_2)
        code.add_label(label_1)
        code.add_command("push", "1")
        code.add_label(label_2)

    elif root.rule == rules.E_inc_after:
        # for stuff like (a)++
        left_base = root.children[0]
        while left_base.rule == rules.E_parens: left_base = left_base.children[1]

        # The code is very similar to the equality rules--see those above for explanation
        if left_base.rule == rules.E_var:
            var_loc = info.get(left_base.children[0].text)
            code.add_command("mov", "rax", "[rbp - " + str(8*var_loc[0]) + "]")
            code.add_command("push", "rax")
            if root.children[1].text == "++":
                if var_loc[1].pointers == 0:
                    code.add_command("inc", "rax")
                else:
                    code.add_command("add", "rax", "8")
            elif root.children[1].text == "--":
                if var_loc[1].pointers == 0:
                    code.add_command("dec", "rax")
                else:
                    code.add_command("sub", "rax", "8")
            else: raise RuleGenException(root.rule)
            code.add_command("mov", "[rbp - " + str(8*var_loc[0]) + "]", "rax")
            info.t = var_loc[1]
        elif left_base.rule == rules.E_point:
            info = make_code(left_base.children[1], info, code)
            code.add_command("pop", "rax")
            code.add_command("push", "qword [rax]")
            if info.t.pointers == 0: raise RuleGenException(root.rule)
            info.t = Type(info.t.type_name, info.t.pointers-1)
            if root.children[1].text == "++":
                if info.t.pointers == 0:
                    code.add_command("inc", "qword [rax]")
                else:
                    code.add_command("add", "qword [rax]", "8")
            elif root.children[1].text == "--":
                if info.t.pointers == 0:
                    code.add_command("dec", "qword [rax]")
                else:
                    code.add_command("sub", "qword [rax]", "8")
            else: raise RuleGenException(root.rule)
        elif left_base.rule == rules.E_array:
            info = make_code(left_base.children[2], info, code)
            info = make_code(left_base.children[0], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule) 
            info.t = Type(info.t.type_name, info.t.pointers - 1)
            code.add_command("pop", "rax") # right hand side
            code.add_command("pop", "rbx") # rcx[r8]
            code.add_command("imul", "rbx", "8")
            code.add_command("add", "rax", "rbx")
            code.add_command("push", "qword [rax]")
            if root.children[1].text == "++":
                if info.t.pointers == 0:
                    code.add_command("inc", "qword [rax]")
                else:
                    code.add_command("add", "qword [rax]", "8")
            elif root.children[1].text == "--":
                if info.t.pointers == 0:
                    code.add_command("dec", "qword [rax]")
                else:
                    code.add_command("sub", "qword [rax]", "8")
            else: raise RuleGenException(root.rule)

    elif root.rule == rules.E_inc_before:
        left_base = root.children[1]
        while left_base.rule == rules.E_parens: left_base = left_base.children[1]

        if left_base.rule == rules.E_var:
            var_loc = info.get(left_base.children[0].text)
            code.add_command("mov", "rax", "[rbp - " + str(8*var_loc[0]) + "]")
            if root.children[0].text == "++":
                if var_loc[1].pointers == 0:
                    code.add_command("inc", "rax")
                else:
                    code.add_command("add", "rax", "8")
            elif root.children[0].text == "--":
                if var_loc[1].pointers == 0:
                    code.add_command("dec", "rax")
                else:
                    code.add_command("sub", "rax", "8")
            else: raise RuleGenException(root.rule)
            code.add_command("push", "rax")
            code.add_command("mov", "[rbp - " + str(8*var_loc[0]) + "]", "rax")
            info.t = var_loc[1]
        elif left_base.rule == rules.E_point:
            info = make_code(left_base.children[1], info, code)
            code.add_command("pop", "rax")
            if info.t.pointers == 0: raise RuleGenException(root.rule)
            info.t = Type(info.t.type_name, info.t.pointers-1)
            if root.children[0].text == "++":
                if info.t.pointers == 0:
                    code.add_command("inc", "qword [rax]")
                else:
                    code.add_command("add", "qword [rax]", "8")
            elif root.children[0].text == "--":
                if info.t.pointers == 0:
                    code.add_command("dec", "qword [rax]")
                else:
                    code.add_command("sub", "qword [rax]", "8")
            else: raise RuleGenException(root.rule)
            code.add_command("push", "qword [rax]")
        elif left_base.rule == rules.E_array:
            info = make_code(left_base.children[2], info, code)
            info = make_code(left_base.children[0], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule) 
            info.t = Type(info.t.type_name, info.t.pointers - 1)
            code.add_command("pop", "rax") # right hand side
            code.add_command("pop", "rbx") # rcx[r8]
            code.add_command("imul", "rbx", "8")
            code.add_command("add", "rax", "rbx")
            if root.children[0].text == "++":
                if info.t.pointers == 0:
                    code.add_command("inc", "qword [rax]")
                else:
                    code.add_command("add", "qword [rax]", "8")
            elif root.children[0].text == "--":
                if info.t.pointers == 0:
                    code.add_command("dec", "qword [rax]")
                else:
                    code.add_command("sub", "qword [rax]", "8")
            else: raise RuleGenException(root.rule)
            code.add_command("push", "qword [rax]")

    elif root.rule == rules.E_point:
        info = make_code(root.children[1], info, code)
        if info.t.pointers == 0: raise RuleGenException(root.rule)
        code.add_command("pop", "rax")
        code.add_command("push", "qword [rax]")
        info.t = Type(info.t.type_name, info.t.pointers - 1)

    elif root.rule == rules.E_deref:
        left_base = root.children[1]
        while left_base.rule == rules.E_parens: left_base = left_base.children[1]

        if left_base.rule == rules.E_var:
            # if it's a variable, just push the variable's address
            var_loc = info.get(left_base.children[0].text)
            code.add_command("lea", "rax", "[rbp - " + str(8*var_loc[0]) + "]")
            code.add_command("push", "rax")
            info.t = Type(var_loc[1].type_name, var_loc[1].pointers + 1)
        elif left_base.rule == rules.E_point:
            # lol if it's a dereferenced pointer, it's just the argument
            info = make_code(left_base.children[1], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule)
        elif left_base.rule == rules.E_array:
            # if it's an array, it's a bit tricky but not too bad
            info = make_code(left_base.children[2], info, code)
            info = make_code(left_base.children[0], info, code)
            if info.t.pointers == 0: raise RuleGenException(root.rule)
            code.add_command("pop", "rax")
            code.add_command("pop", "rbx")
            code.add_command("imul", "rbx", "8")
            code.add_command("add", "rax", "rbx")
            code.add_command("push", "rax")
        else: raise RuleGenException(root.rule)

    elif root.rule == rules.E_func_noarg:
        # Function call without any arguments

        # the function name should be just a variable, not an expression
        if root.children[0].rule != rules.E_var:
            raise RuleGenException(root.rule)
        else:
            fname = root.children[0].children[0].text # function name
            f = info.get_func(fname)
            if f["args"]: raise RuleGenException(root.rule)
            else:
                retlabel = code.get_label()
                code.add_command("lea", "rax", "[rel " + retlabel + "]")
                # push current execution position to stack
                code.add_command("push", "rax")
                # push the current rbp to the stack
                code.add_command("push", "rbp")
                # move the rbp to the rsp to mask local variables
                code.add_command("mov", "rbp", "rsp")
                # jump to the function code
                code.add_command("jmp", f["label"])
                # add label for where to return after function executes
                code.add_label(retlabel)
                info.t = f["ftype"]

    elif root.rule == rules.E_func_call_end:
        # Parse through to get the function call information
        Es = [] # list of expressions of the arguments, in backwards order
        func = None
        node = root
        while True:
            if node.rule == rules.E_func_call_end:
                node = node.children[0]
            elif node.rule == rules.E_func_call_cont:
                Es.append(node.children[2])
                node = node.children[0]
            elif node.rule == rules.E_func_call_start:
                Es.append(node.children[2])
                func = node.children[0]
                Es.reverse()
                break
            
        if func.rule != rules.E_var: raise RuleGenException(root.rule)
        else:
            fname = func.children[0].text
            f = info.get_func(fname)
            # complain if number of arguments provided doesn't match expected
            if len(f["args"]) != len(Es): raise RuleGenException(root.rule)
            
            retlabel = code.get_label()
            code.add_command("lea", "rax", "[rel " + retlabel + "]")
            # push current execution position to stack
            code.add_command("push", "rax")
            # push current rbp to the stack
            code.add_command("push", "rbp")
            # push each argument to the stack
            for node in Es:
                info = make_code(node, info, code)
            # move the rbp to [rsp + 8 * # args] to mask local variables
            code.add_command("lea", "rbp", "[rsp + " + str(8*len(Es)) + "]")
            # jump to the function code
            code.add_command("jmp", f["label"])
            # add label for where to return after function executes
            code.add_label(retlabel)
            info.t = f["ftype"]

    elif root.rule == rules.E_array:
        # stuff of the form `arr[5]`
        info = make_code(root.children[2], info, code)
        info = make_code(root.children[0], info, code)
        info.t = Type(info.t.type_name, info.t.pointers - 1)
        code.add_command("pop", "rax")
        code.add_command("pop", "rbx")
        code.add_command("imul", "rbx", "8")
        code.add_command("add", "rax", "rbx")
        code.add_command("push", "qword [rax]")

    elif root.rule == rules.E_var:
        var_loc = info.get(root.children[0].text)
        code.add_command("push", "qword [rbp - " + str(8*var_loc[0]) + "]")
        info.t = var_loc[1]

    elif root.rule == rules.E_form:
        info = make_code(root.children[0], info, code)

    elif root.rule in [rules.if_form_brackets,
                       rules.if_form_oneline,
                       rules.if_form_main]:
        info = make_code(root.children[1], info, code, loop_break=loop_break, loop_continue=loop_continue)
        code.add_command("pop", "rax")
        code.add_command("cmp", "rax", "0")
        endif_label = code.get_label()
        code.add_command("je", endif_label)

        if root.rule == rules.if_form_main:
            # Do not update info because the stuff inside the if is in a different scope
            make_code(root.children[4], info, code, loop_break=loop_break, loop_continue=loop_continue)
        elif root.rule == rules.if_form_oneline:
            make_code(root.children[3], info, code, loop_break=loop_break, loop_continue=loop_continue) # do not update info
            
        if has_else:
            code.add_command("jmp", endelse_label)
        code.add_label(endif_label)

    elif root.rule in [rules.else_form_brackets,
                       rules.else_form_oneline,
                       rules.else_form_main]:

        if root.rule == rules.else_form_oneline:
            make_code(root.children[1], info, code, loop_break=loop_break, loop_continue=loop_continue) # do not update info
        elif root.rule == rules.else_form_main:
            make_code(root.children[2], info, code, loop_break=loop_break, loop_continue=loop_continue) # do not update info

    elif root.rule == rules.if_form_general:
        info = make_code(root.children[0], info, code, loop_break=loop_break, loop_continue=loop_continue)

    elif root.rule == rules.ifelse_form_general:
        end_else = code.get_label()
        info = make_code(root.children[0], info, code, True, end_else, loop_break=loop_break, loop_continue=loop_continue)
        info = make_code(root.children[1], info, code, loop_break=loop_break, loop_continue=loop_continue)
        code.add_label(end_else)

    elif root.rule == rules.break_form:
        # break command in a loop
        if loop_break:
            code.add_command("jmp", loop_break)
        else: # complain if it wasn't in a loop
            raise RuleGenException(root.rule)

    elif root.rule == rules.cont_form:
        # continue command in a loop
        if loop_continue:
            code.add_command("jmp", loop_continue)
        else: # complain if it wasn't in a loop
            raise RuleGenException(root.rule)

    elif root.rule in [rules.while_form_main,
                       rules.while_form_oneline,
                       rules.while_form_brackets]:
        startwhile = code.get_label()
        endwhile = code.get_label()
        
        code.add_label(startwhile)
        info = make_code(root.children[1], info, code)
        code.add_command("pop", "rax")
        code.add_command("cmp", "rax", "0")
        code.add_command("je", endwhile)
        if root.rule == rules.while_form_oneline:
            make_code(root.children[3], info, code, loop_break = endwhile, loop_continue = startwhile) # do not update info
        elif root.rule == rules.while_form_main:
            make_code(root.children[4], info, code, loop_break = endwhile, loop_continue = startwhile) # do not update info
        code.add_command("lea", "rsp", "[rbp - " + str(info.var_offset * 8) +  "]") # move rsp back to its place before going on
        code.add_command("jmp", startwhile)
        code.add_label(endwhile)

    elif root.rule in [rules.for_form_brackets,
                       rules.for_form_oneline,
                       rules.for_form_main]:
        startfor = code.get_label() # label to start the for loop
        endfor = code.get_label() # label to end the for loop
        cont_point = code.get_label() # label for where to go when you continue

        info_temp = make_code(root.children[0]
                              .children[0]
                              .children[0]
                              .children[1], info, code)
        code.add_label(startfor)
        exp2 = root.children[0].children[0].children[1].children[0] # oh my
        if exp2.rule == rules.E_form:
            make_code(exp2, info_temp, code)
            code.add_command("pop", "rax")
            code.add_command("cmp", "rax", "0")
            code.add_command("je", endfor)
            if root.rule == rules.for_form_oneline:
                make_code(root.children[1], info_temp, code, loop_break=endfor, loop_continue=cont_point)
            elif root.rule == rules.for_form_main:
                make_code(root.children[2], info_temp, code, loop_break=endfor, loop_continue=cont_point)

            code.add_label(cont_point)
            
            if root.children[0].rule == rules.for_expr_form:
                make_code(root.children[0].children[1], info_temp, code)
            elif root.children[0].rule == rules.for_expr_form_empty:
                pass
            
            code.add_command("lea", "rsp", "[rbp - " + str(info_temp.var_offset * 8) +  "]") # move rsp back to its place before going on
            code.add_command("jmp", startfor)
            code.add_label(endfor)
        else: raise RuleGenException(root.rule)
        
    elif root.rule == rules.semicolon_form: pass

    # If none of these rules applied, something went wrong. Complain.
    else:
        raise RuleGenException(root.rule)
    
    return info
